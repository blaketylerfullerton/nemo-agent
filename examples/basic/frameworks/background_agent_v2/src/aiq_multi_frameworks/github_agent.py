import logging
import os
import subprocess
import time
import tempfile
import git
import requests
from aiq.builder.builder import Builder
from aiq.builder.function_info import FunctionInfo
from aiq.cli.register_workflow import register_function
from aiq.data_models.component_ref import LLMRef
from aiq.data_models.function import FunctionBaseConfig
import re
from openai import OpenAI
from pydantic import Field

client = OpenAI(
  base_url = "https://integrate.api.nvidia.com/v1",
  api_key = os.getenv("NVIDIA_API_KEY")
)

logger = logging.getLogger(__name__)

class GithubAgentConfig(FunctionBaseConfig, name="github_agent"):
    """Configuration for the GitHub agent.

    Attributes
    ----------
    github_token
        A GitHub personal access token with permissions to push to the target repository and open pull
        requests. Defaults to the ``GITHUB_TOKEN`` environment variable if not provided explicitly.
    repo_owner
        The owner (user or organisation) of the target repository.
    repo_name
        The name of the target repository.
    base_branch
        The branch that the pull-request should target. Defaults to ``main``.
    """

    github_token: str = Field(default_factory=lambda: os.getenv("GITHUB_TOKEN"))
    repo_owner: str
    repo_name: str
    base_branch: str = Field(default="main")


@register_function(config_type=GithubAgentConfig)
async def github_agent_as_tool(tool_config: GithubAgentConfig, builder: Builder):

    async def _arun(repo_path: str, changes: str) -> str:
        """Commit *changes* that have already been applied to the working tree at *repo_path* and open
        a pull-request on GitHub.

        The function performs the following steps:

        1. Creates a new branch derived from the configured base branch.
        2. Uses an LLM to generate an appropriate PR title and description from *changes*.
        3. Commits all modified files with the generated commit message.
        4. Pushes the branch to GitHub using the provided token.
        5. Opens a pull-request and returns its URL.
        """
        try:
            logger.info("Creating commit and PR for repository %s", repo_path)

            # Initialise repository object
            repo = git.Repo(repo_path)

            # Ensure we are on the base branch before creating a feature branch
            try:
                repo.git.checkout(tool_config.base_branch)
            except git.exc.GitCommandError:
                # Fallback to whatever branch we're already on
                logger.warning("Base branch %s not found. Continuing on the current branch.", tool_config.base_branch)

            # Create a new unique branch for the PR
            branch_name = f"ai-improvements-{int(time.time())}"
            repo.git.checkout('-b', branch_name)

            # Stage all current modifications (Nemo agent should have already applied them)
            repo.git.add(all=True)

            # If there are no staged changes, exit early
            if not repo.is_dirty(untracked_files=True):
                logger.warning("No changes detected in the working tree – nothing to commit.")
                return "❌ No changes found in the repository. Commit and PR were not created."

            # Use LLM to generate a commit title & body
            llm_prompt = (
                "You are an expert software engineer. You speak like an old man "
                "Write a concise, conventional commit title (max 72 characters) and a detailed "
                "commit body that explains *why* the change is made. "
                "The commit should reflect the following code diff or description:\n\n" + changes[:4000]
            )

            llm_response = client.chat.completions.create(
                model="nvidia/llama-3.1-nemotron-70b-instruct",
                messages=[{"role": "user", "content": llm_prompt}],
                temperature=0.2,
                max_tokens=400
            )

            commit_text = llm_response.choices[0].message.content.strip()

            # Split the first line as title, rest as body
            commit_lines = commit_text.splitlines()
            commit_title = commit_lines[0][:72]
            commit_body = "\n".join(commit_lines[1:]).strip() if len(commit_lines) > 1 else "Generated by AI"
            commit_message = f"{commit_title}\n\n{commit_body}"

            # Perform the commit
            repo.index.commit(commit_message)

            # Prepare authenticated remote URL
            origin = repo.remote()
            auth_remote_url = f"https://{tool_config.github_token}@github.com/{tool_config.repo_owner}/{tool_config.repo_name}.git"
            origin.set_url(auth_remote_url)

            # Push the branch
            origin.push(branch_name, set_upstream=True)

            # Use LLM result to craft PR title & body
            pr_title = commit_title
            pr_body = commit_body + "\n\n_(This PR was generated automatically by an AI agent.)_"

            pr_endpoint = f"https://api.github.com/repos/{tool_config.repo_owner}/{tool_config.repo_name}/pulls"
            headers = {
                "Authorization": f"token {tool_config.github_token}",
                "Accept": "application/vnd.github+json"
            }
            pr_payload = {
                "title": pr_title,
                "head": branch_name,
                "base": tool_config.base_branch,
                "body": pr_body
            }

            pr_response = requests.post(pr_endpoint, headers=headers, json=pr_payload, timeout=30)
            pr_response.raise_for_status()
            pr_url = pr_response.json().get("html_url", "<unknown>")

            return (
                "✅ GitHub Agent successfully committed changes and opened a PR.\n\n"
                f"Branch: {branch_name}\n"
                f"Commit message: {commit_title}\n"
                f"PR URL: {pr_url}"
            )

        except Exception as e:
            logger.error(f"GitHub Agent error: {e}")
            return f"❌ GitHub Agent failed: {str(e)}"

    yield FunctionInfo.from_fn(_arun, description="Validate repo, commit changes, and open a pull request.")






